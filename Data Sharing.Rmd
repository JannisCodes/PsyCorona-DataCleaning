---
title: "Psycorona - Data Sharinh"
subtitle: "Step by step description" 
author: "PsyCorona Gang"
date: "3/30/2020"
output:
  html_document: 
    code_folding: hide
    mathjax: default
    theme: yeti
    toc: yes
    toc_float: yes
editor_options:
  chunk_output_type: console
---


<style type="text/css">
.main-container {
  max-width: 1300px;
  margin-left: auto;
  margin-right: auto;
}
.table {
  margin-left:auto; 
  margin-right:auto;
}
</style>


```{r setup, include=FALSE}
# R Studio Clean-Up
  cat("\014") # clear console
  rm(list=ls()) # clear workspace
  gc # garbage collector
  
# Install and Load Packages
  #if(!require(pacman)) install.packages("pacman")
  # require(pacman)
  # pacman::p_load(psych, ggplot2, ggthemes, haven, data.table, dplyr, tidyr, Hmisc, mada, 
  #                knitr, kableExtra, naniar, stats, readxl, matrixStats, ISOcodes, pander,
  #                Scale)
lib <- c("psych", "ggplot2", "ggthemes", "haven", "data.table", "dplyr", "tidyr", "Hmisc", "mada", 
         "knitr", "kableExtra", "naniar", "stats", "readxl", "matrixStats", "ISOcodes", "pander", "Scale",
         "dply")

invisible(lapply(lib, library, character.only = TRUE))  
lapply(lib, library, character.only = TRUE)
rm(lib)  

# Load Custom Packages  
  source("./scripts/functions/fun.panel.R")
  source("./scripts/functions/themes.R")
  source("./scripts/functions/dictionary_functions.R")
  
# Markdown Options
  knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # set working directory
  knitr::opts_knit$get("root.dir") # check working directory
  options(scipen = 999, digits = 4, width = 400) #removes scientific quotation
  #knitr::opts_chunk$set(echo = TRUE, cache = F, cache.path = rprojroot::find_rstudio_root_file('cache/')) # cache settings
  knitr::knit_hooks$set(
   error = function(x, options) {
     paste('\n\n<div class="alert alert-danger">',
           gsub('##', '\n', gsub('^##\ Error', '**Error**', x)),
           '</div>', sep = '\n')
   },
   warning = function(x, options) {
     paste('\n\n<div class="alert alert-warning">',
           gsub('##', '\n', gsub('^##\ Warning:', '**Warning**', x)),
           '</div>', sep = '\n')
   },
   message = function(x, options) {
     paste('\n\n<div class="alert alert-info">',
           gsub('##', '\n', x),
           '</div>', sep = '\n')
   }
  )
  htmltools::tagList(rmarkdown::html_dependency_font_awesome())

# Global Chunk Options
  knitr::opts_chunk$set(echo = TRUE)
```

Note. Boxplots display the interquartile range (IQR, center box), and the whiskers extend 1.5*IQR from the lower and upper hinge. The white point indicates the mean and the white center line indicates the median.   

<br/>

## **Preparation**
In a first step we import the raw Qualtrics data, which was downloaded as an SPSS file.   
### Import Data
```{r LoadRawBase, echo=T, warning=F, message=F}
# Reset working directory to folder current file is saved in
#setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

# Import Qualtrics Survey Data (new but no localization)
  dtAll <- haven::read_spss("data/collab data/Shared/Data/cleaned data/Psycorona Baseline cleaned - All 2021-10-28 15-32 UTC_noLocalization.sav")
# map localization data to responses (only possible until December)
  dtAllLocal <- haven::read_spss("data/collab data/Shared/Data/cleaned data/Psycorona Baseline cleaned - All 2020-10-25 12-22 CET Region Only.sav") #load old region
  dtAll <- dplyr::left_join(dtAll, dtAllLocal, by = "ResponseId") # merge
  rm(dtAllLocal) 
# Import Qualtrics Survey Data
  # dtAll <- haven::read_spss("data/collab data/Shared/Data/cleaned data/Psycorona Baseline cleaned - All 2020-10-25 12-22 CET.sav")
  dtAll$representative <- dtAll$source
  # recode source so not identifiable
    dtAll$source <- dplyr::recode(dtAll$source, "Fly" = 1, "HNATD" = 2, "Iran" = 3, "NYU-AD" = 4, "RUG" = 5, "Rep NYU-AD" = 6, "Rep RUG" = 7, "Rep China" = 8)
    table(dtAll$representative, dtAll$source) # for checking
    
# Import Harmonized Data (new but no localization)
  dtAllHarmo <- haven::read_spss("data/collab data/Shared/Data/cleaned data/Psycorona Baseline cleaned - All Harmonized 2021-10-28 15-32 UTC_noLocalization.sav")
# Import Harmonized Data
  # dtAllHarmo <- haven::read_spss("data/collab data/Shared/Data/cleaned data/Psycorona Baseline cleaned - All Harmonized 2020-10-25 12-22 CET.sav")
  
# Import Request sheet
  url <- gsheet::construct_download_url('https://docs.google.com/spreadsheets/d/13PFXsmgjrZBNddHodR2Z_80cjicN4s7yd8BbazKffx8/edit?usp=sharing', format = "csv", sheetid = NULL)
  dtReq <- gsheet::gsheet2tbl(url, sheetid = NULL); rm(url)
  namedtReq <- dtReq[1,]
  dtReq <- dtReq[-c(1:3),]
  
  # Meta request sheet (rows 300 until end)
  dtReqMeta <- dtReq[c(385:nrow(dtReq)),]
  # normal request sheet the first rows
  dtReq <- dtReq[c(1:380),]
```

Prepare Caspar van Lissa's library and functions
```{r}
library(countrycode)
source(file.path("scripts", "functions", "merge_metadata.R"))

metadata_location <- file.path("data", "metadata")
get_metadata(metadata_location, overwrite = F)
# deleting the metadata folder and reloading solves quite some issues
```

### Function for Data
```{r fctExp, echo=T, warning=F, message=F}
stringOut <- NA #make var for fill out in function
  source("./scripts/functions/nameOut.R") # load nameOut function

# ADD WARNING IF ZIP CODE REQUESTED
```

### Function for Data Creation
```{r}
# RMD <- "RMD05"
# seedNum <- 05

dataCreate <- function(RMD, seedNum){
# prepare dataframe
name <- RMD
# from here everything is automatic (just need to change the name above)
  author <- namedtReq %>%
    dplyr::select(one_of(paste0(name, '_vars'))) %>% # select the column in which the name and vars are
    as.character() # make it a character
  author <- strsplit(author, "\n")[[1]][3] # get the author which is the third occurence after \n

# make df  
  varReq <- dtReq %>% 
    dplyr::select(name = var, # get variable names
                  request = one_of(paste0(name, '_vars'))) # and the requested columns
 
  varReq <- varReq %>% #remove empty rows
    dplyr::filter(request != "") 
  
# run function to get requested variable names 
  varNames <- apply(varReq, 1, nameOut); rm(varReq)

# make dataframe
  dt <- dtAll %>%
    dplyr::select(one_of(as.character(varNames)),
                 -contains("_DO_"),
                 -contains(".c"),
                 -contains(".m"),
                 -contains(".z"),
                 -contains(".fa"),
                 -contains("ZIP", ignore.case = T),
                 -ends_with("_TEXT", ignore.case = T),
                 -countryCitizenIfNo,
                 -contains("region"),
                 -whatRel)
  
# add harmonized data if grandMean and Sd are requested
    if(sum(grepl("respSetMean", names(dt))) > 0 ){ # if response Set Mean is requested
        print("Merging Participant Mean and Sd. Please wait...")
        dtHarmo <- dtAllHarmo %>% 
          dplyr::select(one_of(as.character(varNames))) #make harmonized continous variable dataset
        colnames(dtHarmo) <- paste(colnames(dtHarmo), "Harmonized",  sep = "_")
        # and add harmonized variables to requested dt
        dt <- cbind(dt, dtHarmo); rm(dtHarmo)
  } else { # if not
    print("Participant Mean and Sd not requested!") # keep dt
  }

# needs response ID (make through digest)
  dt$ResponseId <- c(1:nrow(dt))
  for (i in 1:nrow(dt)) {
  dt$ResponseId[i] <- digest::digest(dtAll$ResponseId[i], algo = "xxhash32", seed = seedNum)
    }
  
# add representative info if needed
  if(sum(grepl("representative", names(dt))) == 1 ){ # if the sum of columns that have the string representative == 2
    print("Adding Representative indication. Please wait...")
    dt$representative <- factor(dtAll$source, 
                                levels = c(1,2,3,4,5,6,7,8), 
                                labels = c("No", "No", "No", "No", "No", "Yes", "Yes", "Yes"))  # add column for representative
  } else { # if not
    print("Representative indication not requested!")
    dt <- dt # keep dt
  }
  
# Merge Requested Meta-Data to requested variables
  # make df  
    metaReq <- dtReqMeta %>% 
      dplyr::select(origin = Origin,
                    path = var, # get variable names
                    mergTech = min,
                    request = one_of(paste0(name, '_vars'))) # and the requested columns
  
   metaReq <- metaReq %>% #remove empty rows
    dplyr::filter(request != "")
  # split the string at "/" and get the fifth; also remove everything after the dot; for loop needed so it does for each row
  # seperately
   if(nrow(metaReq) > 0 ){
     metaReq$name <- NA
     for(i in 1:nrow(metaReq)) {
       metaReq$name[i] <- gsub(".csv", "", strsplit(metaReq$path[i], "[/]")[[1]][5])  
     }
     rm(i)
   }
     
  # print the requested datasets and run for loop for the merge
    if(nrow(metaReq) == 0){ # if row length is 0
      print("No Meta-Data requested")
    } else { # if not
      # make the country merg (important for longitudinal data)
      dt$mergCtry <- countrycode::countrycode(dt$coded_country, origin = "country.name", destination = "iso3c")
      
      # for loop to merge each dataset according to its merging mechanism (iso or more complicated)
        for (i in 1:nrow(metaReq)) {
          if(metaReq$mergTech[i] == "countryiso3") {
            print(paste("Merging ", metaReq$name[i], ". Please Wait...", sep = "")) #which variable is merging
            dt <- merge_files(dt, metaReq$name[i], metadata_location)
          }
        # longitudinal data
          else if(metaReq$mergTech[i] == "long_DateNum_iso3") {
            print(paste("Merging ", metaReq$name[i], ". Please wait...", sep = ""))
            print("Always check whether these datasets are up to date!")
          # load data
            dtMeta <- read.csv(metaReq$path[i], stringsAsFactors = FALSE)
          # do we have regional data?
            if("RegionName" %in% colnames(dtMeta)) {
                tmp <- dtMeta %>% filter(RegionName != "")
                print(paste("There is regional data available for: ", unique(tmp$CountryCode), "!", sep = "")); rm(tmp)
                print("Ignored and deleted for now.")
              dtMeta <- dtMeta %>% filter(RegionName == "")
            }
            else {
              (print("No Regional data available (but may need a manual check if too many rows appear in data)"))
            } 
            # prepare merg data
              dtMeta$mergCtry <- dtMeta$CountryCode
              dtMeta$mergDate <- as.numeric(dtMeta$Date)
          # Baseline (always first: make time merge variables)
            dt$mergDate <- as.numeric(paste0(substr(dt$EndDate, 1, 4), substr(dt$EndDate, 6, 7), 
                                             substr(dt$EndDate, 9, 10)))
            # merge
              dt <- dplyr::left_join(dt, dtMeta, by=c("mergCtry","mergDate"))
          # Wave 1
            dt$mergDate <- as.numeric(paste0(substr(dt$w1_EndDate , 1, 4), substr(dt$w1_EndDate , 6, 7), #overwrite mergDate
                                             substr(dt$w1_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w1", colnames(dtMeta), sep = "_") # add string before column name
              data.table::setnames(tmp, "w1_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w1_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 2
            dt$mergDate <- as.numeric(paste0(substr(dt$w2_EndDate , 1, 4), substr(dt$w2_EndDate , 6, 7),
                                                substr(dt$w2_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w2", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w2_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w2_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 3
            dt$mergDate <- as.numeric(paste0(substr(dt$w3_EndDate , 1, 4), substr(dt$w3_EndDate , 6, 7),
                                                substr(dt$w3_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w3", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w3_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w3_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 4
            dt$mergDate <- as.numeric(paste0(substr(dt$w4_EndDate , 1, 4), substr(dt$w4_EndDate , 6, 7),
                                                substr(dt$w4_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w4", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w4_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w4_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 5
            dt$mergDate <- as.numeric(paste0(substr(dt$w5_EndDate , 1, 4), substr(dt$w5_EndDate , 6, 7),
                                                substr(dt$w5_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w5", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w5_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w5_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 6
            dt$mergDate <- as.numeric(paste0(substr(dt$w6_EndDate , 1, 4), substr(dt$w6_EndDate , 6, 7),
                                                substr(dt$w6_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w6", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w6_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w6_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 7
            dt$mergDate <- as.numeric(paste0(substr(dt$w7_EndDate , 1, 4), substr(dt$w7_EndDate , 6, 7),
                                                substr(dt$w7_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w7", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w7_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w7_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 8
            dt$mergDate <- as.numeric(paste0(substr(dt$w8_EndDate , 1, 4), substr(dt$w8_EndDate , 6, 7),
                                                substr(dt$w8_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w8", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w8_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w8_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 9
            dt$mergDate <- as.numeric(paste0(substr(dt$w9_EndDate , 1, 4), substr(dt$w9_EndDate , 6, 7),
                                                substr(dt$w9_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w9", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w9_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w9_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 10
            dt$mergDate <- as.numeric(paste0(substr(dt$w10_EndDate , 1, 4), substr(dt$w10_EndDate , 6, 7),
                                                 substr(dt$w10_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w10", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w10_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w10_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 11
            dt$mergDate <- as.numeric(paste0(substr(dt$w11_EndDate , 1, 4), substr(dt$w11_EndDate , 6, 7),
                                                 substr(dt$w11_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w11", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w11_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w11_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 12
            dt$mergDate <- as.numeric(paste0(substr(dt$w12_EndDate , 1, 4), substr(dt$w12_EndDate , 6, 7),
                                                 substr(dt$w12_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w12", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w12_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w12_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 13
            dt$mergDate <- as.numeric(paste0(substr(dt$w13_EndDate , 1, 4), substr(dt$w13_EndDate , 6, 7),
                                                 substr(dt$w13_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w13", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w13_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w13_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 14
            dt$mergDate <- as.numeric(paste0(substr(dt$w14_EndDate , 1, 4), substr(dt$w14_EndDate , 6, 7),
                                                 substr(dt$w14_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w14", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w14_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w14_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 15
            dt$mergDate <- as.numeric(paste0(substr(dt$w15_EndDate , 1, 4), substr(dt$w15_EndDate , 6, 7),
                                                 substr(dt$w15_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w15", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w15_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w15_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 16
            dt$mergDate <- as.numeric(paste0(substr(dt$w16_EndDate , 1, 4), substr(dt$w16_EndDate , 6, 7),
                                                 substr(dt$w16_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w16", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w16_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w16_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 17
            dt$mergDate <- as.numeric(paste0(substr(dt$w17_EndDate , 1, 4), substr(dt$w17_EndDate , 6, 7),
                                                 substr(dt$w17_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w17", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w17_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w17_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 18
            dt$mergDate <- as.numeric(paste0(substr(dt$w18_EndDate , 1, 4), substr(dt$w18_EndDate , 6, 7),
                                                 substr(dt$w18_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w18", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w18_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w18_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 19
            dt$mergDate <- as.numeric(paste0(substr(dt$w19_EndDate , 1, 4), substr(dt$w19_EndDate , 6, 7),
                                                 substr(dt$w19_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w19", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w19_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w19_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 20
            dt$mergDate <- as.numeric(paste0(substr(dt$w20_EndDate , 1, 4), substr(dt$w20_EndDate , 6, 7),
                                                 substr(dt$w20_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w20", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w20_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w20_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 21
            dt$mergDate <- as.numeric(paste0(substr(dt$w21_EndDate , 1, 4), substr(dt$w21_EndDate , 6, 7),
                                                 substr(dt$w21_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w21", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w21_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w21_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry
          # Wave 22
            dt$mergDate <- as.numeric(paste0(substr(dt$w22_EndDate , 1, 4), substr(dt$w22_EndDate , 6, 7),
                                                 substr(dt$w22_EndDate , 9, 10)))
            # merge
              tmp <- dtMeta # make temporary df where I can change names without affecting later functions
              colnames(tmp) <- paste("w22", colnames(tmp), sep = "_") # add string before column name
              data.table::setnames(tmp, "w22_mergCtry", "mergCtry") # we change them back to the merge names
              data.table::setnames(tmp, "w22_mergDate", "mergDate") # we change them back to the merge names
              dt <- dplyr::left_join(dt, tmp, by=c("mergCtry","mergDate")); rm(tmp) # and we merge by new date but old ctry

          }
          else {
            print(paste("Merging complicated stuff: ", metaReq$name[i], ". Computer says no...", sep = ""))
          }
  
        } 
      # # remove irrelevant columns 
      #   dt <- dt %>%
      #    dplyr::select(-matches('^country..$'),
      #                  -matches('^region..$'),
      #                  -countryiso3)  
    }
 
 

# Export Dataframe
# Naming
  namSPSS <- paste0("data/collab data/c19 collab Data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),".sav")
   namCSV <- paste0("data/collab data/c19 collab Data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),".csv")
# Export
  write_sav(dt, namSPSS)
  write.csv(dt, file = namCSV)
rm(dt, namSPSS, namCSV)
}

# dataCreate("RMD00", 00)
```

### Data Stuff
```{r bertDemo}
# how much responses per country
  tmp <- dtAll %>% 
  group_by(coded_country)  # group by country
  # filter(n() > 50) 

# how much responses per wave
  tmp <- tmp %>%
    dplyr::select(contains("affAnx"), -contains("DO"))%>%
     dplyr::mutate_all(~ifelse(is.na(.), 0, 1))
  tmp$nBoth <- rowSums(tmp[,2:ncol(tmp)])
  tmp$representative <- factor(dtAll$source, 
                                levels = c(1,2,3,4,5,6,7,8), 
                                labels = c("No", "No", "No", "No", "No", "Yes", "Yes", "Yes"))
# seperate date df
  tmpDate <- dtAll %>%
    dplyr::select(contains("RecordedDate"))
  # combine date df and response df
    tmp <- cbind(tmp, tmpDate)

  table(tmp$representative, tmp$nBoth)
  tmpOut2 <- table(tmp$representative, tmp$nBoth, tmp$coded_country)
  tmpOut <- table(tmp$coded_country, tmp$nBoth)
  
# export if needed
write.csv(tmp,'data/cleaned data/respRatePerCtry+source+date.csv')
write.csv(tmpOut2,'data/cleaned data/respRatePerCtry+source+representative.csv')

write.csv(tmpOut,'data/cleaned data/outputPerCtry.csv')
write.csv(tmpOut,'data/cleaned data/outputPerLng.csv')
```

### RMD00 (Bertus wants gender, age, country table)
```{r bertDemo}
tmp <- dtAll %>%
  group_by(coded_country, age, gender) %>%
  summarise(n = n())
write_sav(tmp, paste0("data/collab data/BertusDemo ", format(Sys.time(), format = "%F %H-%M %Z"),".sav"))
write.csv(tmp, paste0("data/collab data/BertusDemo ", format(Sys.time(), format = "%F %H-%M %Z"),".csv"))
rm(tmp)


```

## Create Datasets
### RMD01 (Representative Sample)
```{r RMD01, echo=T, warning=F, message=F}
dataCreate("RMD01", 01)
```

### RMD02 (Ben Guetzkow): \n Decision-Making during the COVID-19 Pandemic: Predicting Safe and Unsafe behaviors with the Corona Reflection Test
```{r RMD02, echo=T, warning=F, message=F}
dataCreate("RMD02", 02)
```

### RMD03 (Caspar van Lissa): \n Cooperation, Trust, and Behavioral Responses Across Societies During the COVID-19 Pandemic
```{r RMD03, echo=T, warning=F, message=F}
dataCreate("RMD03", 03)
```

### RMD04 (Qing Han): \n Trust in government and its influence on health behaviour and prosocial behaviour during the COVID-19 pandemic
```{r RMD04, echo=T, warning=F, message=F}
dataCreate("RMD04", 04)
```

### RMD05 (Anne Margit): \n Predictors of consistently high well-being during COVID-19
```{r RMD05, echo=T, warning=F, message=F}
dataCreate("RMD05", 05)
```

### RMD06 (Anne Margit): \n Emotional experiences across nations during COVID-19: age, gender, and cultural differences
```{r RMD06, echo=T, warning=F, message=F}
dataCreate("RMD06", 06)
```

### RMD07 (Anne Margit): \n The association of emotional experiences during the height of COVID-19 with well-being across nations
```{r RMD07, echo=T, warning=F, message=F}
dataCreate("RMD07", 07)
```

### RMD08 (Lemay): \n Hope During the COVID-19 Pandemic: Implications for Individual and National Prevention Behaviors, Infection, and Well-Being
```{r RMD08, echo=T, warning=F, message=F}
dataCreate("RMD08", 08)
```

### RMD09 (Abakoumkin): \n Prediction of health protective behavior in the context of COVID-19 pandemic drawing from protection motivation theory
```{r RMD09, echo=T, warning=F, message=F}
dataCreate("RMD09", 09)
```

### RMD10 (Schumpe): \n Adoption of recommended behaviors to fight COVID-19
```{r RMD10, echo=T, warning=F, message=F}
dataCreate("RMD10", 10)
```

### RMD11 (Jin): \n Intergenerational Conflict of Interest and Prosocial Behavior During COVID-19 Pandemic
```{r RMD11, echo=T, warning=F, message=F}
dataCreate("RMD11", 11)
```

### RMD12 (Zuniga): \n Emotions, prosocial behaviour, wellbeing and disempowerment in response to the pandemic
```{r RMD12, echo=T, warning=F, message=F}
dataCreate("RMD12", 12)
```

### RMD13 (Lemay)
```{r RMD13, echo=T, warning=F, message=F}
dataCreate("RMD13", 13)
```

### RMD14 (Quing Han)
```{r RMD14, echo=T, warning=F, message=F}
dataCreate("RMD14", 14)
```

### RMD15 (Claudia Fernandes)
```{r RMD15, echo=T, warning=F, message=F}
dataCreate("RMD15", 15)
```

### RMD16 (van Breen)
```{r RMD16, echo=T, warning=F, message=F}
dataCreate("RMD16", 16)
```

### RMD17 (Bagci)
```{r RMD17, echo=T, warning=F, message=F}
dataCreate("RMD17", 17)
```

### RMD18 (van Veen)
```{r RMD18, echo=T, warning=F, message=F}
# prepare dataframe
name <- 'RMD18'
# from here everything is automatic (just need to change the name above)
  author <- namedtReq %>%
    dplyr::select(one_of(paste0(name, '_vars'))) %>% # select the column in which the name and vars are
    as.character() # make it a character
  author <- strsplit(author, "\n")[[1]][3] # get the author which is the third occurence after \n

# make df  
  tmp <- dtReq %>% 
    dplyr::select(name = var, # get variable names
                  request = one_of(paste0(name, '_vars'))) # and the requested columns
 
  tmp <- tmp %>% #remove empty rows
    dplyr::filter(request != "") 
  
# run function to get requested variable names 
  varNames <- apply(tmp, 1, nameOut); rm(tmp)

# make dataframe
  dt <- dtAll %>%
    dplyr::select(one_of(as.character(varNames)),
                 -contains("_DO_"),
                 -contains(".c"),
                 -contains(".m"),
                 -contains(".z"),
                 -contains(".fa"),
                 -countryCitizenIfNo,
                 -whatRel)
  
# needs response ID (make through digest)
  dt$ResponseId <- c(1:nrow(dt))
  for (i in 1:nrow(dt)) {
  dt$ResponseId[i] <- digest::digest(dtAll$ResponseId[i], algo = "xxhash32", seed = 18)
  }
  
# this dataset only wants the Netherlands
  dt <- dt %>%
  filter(coded_country == "Netherlands") #this proposal only wants the netherlands
  
# prepare dataframe for merge
  postCodeNL <- read.csv("data/raw data/ZIP/NLpostcodetabel.csv", header = T)
  postCodeNL <- postCodeNL %>%
    transmute(mergeID = substr(PostCode, start = 1, stop = 4), #get only first five letters
              level1 = Provincie,
              level2 = Gemeente)
# remove duplicate postal codes from the postal database (we do not need to know their street)
  postCodeNL <- postCodeNL %>%
    dplyr::distinct(mergeID, .keep_all = T)

# make merge ID in the created df
  dt$mergeID <-dt$ZIP_1_TEXT %>%
    tolower() %>% #make them lower case
    gsub(" ", "", ., fixed = TRUE) %>% # remove white space
    as.character()%>%
    substr(., start = 1, stop = 4)
  
# and merge them 
  dt <- dplyr::left_join(dt, postCodeNL, by = "mergeID")
  
# remove ZIP again
  dt <- dt %>%
    dplyr::select(-contains("ZIP", ignore.case = T),
                  -ends_with("_TEXT", ignore.case = T),
                  -contains("mergeID", ignore.case = T))
  
# make representative if needed
  if(sum(grepl("representative", names(dt))) == 1 ){ # if the sum of columns that have the string representative == 2
    dt <- dt[grepl("Rep", dt$representative),]  # reduce df to representative
  } else { # if not
    dt <- dt # keep dt
  }
    
# Export Dataframe
# Naming
  namSPSS <- paste0("data/collab data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),".sav")
  namR <- paste0("data/collab data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),".Rdata")
  namCSV <- paste0("data/collab data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),".csv")
# Export
  write_sav(dt, namSPSS)
  save(dt, file = namR)
  write.csv(dt, file = namCSV)
rm(dt, namSPSS, namR, namCSV)
```

### RMD19 (Buttrick)
```{r RMD19, echo=T, warning=F, message=F}
dataCreate("RMD19", 19)
```

### RMD20 (Agostini)
```{r RMD20, echo=T, warning=F, message=T}
# prepare dataframe
dataCreate("RMD20", 20)

name <- 'RMD20'
# from here everything is automatic (just need to change the name above)
  author <- namedtReq %>%
    dplyr::select(one_of(paste0(name, '_vars'))) %>% # select the column in which the name and vars are
    as.character() # make it a character
  author <- strsplit(author, "\n")[[1]][3] # get the author which is the third occurence after \n
# make df  
  tmp <- dtReq %>% 
    dplyr::select(name = var, # get variable names
                  request = one_of(paste0(name, '_vars'))) # and the requested columns
 
  tmp <- tmp %>% #remove empty rows
    dplyr::filter(request != "") 
  
# run function to get requested variable names 
  varNames <- apply(tmp, 1, nameOut); rm(tmp)
# make dataframe
  dt <- dtAll %>%
    dplyr::select(one_of(as.character(varNames)),
                 -contains("_DO_"),
                 -contains(".c"),
                 -contains(".m"),
                 -contains(".z"),
                 -contains(".fa"),
                 -contains("ZIP", ignore.case = T),
                 -ends_with("_TEXT", ignore.case = T),
                 -countryCitizenIfNo,
                 -whatRel)
  
# needs response ID (make through digest)
  # dt$ResponseId <- c(1:nrow(dt))
  # for (i in 1:nrow(dt)) {
  # dt$ResponseId[i] <- digest::digest(dtAll$ResponseId[i], algo = "xxhash32", seed = 20)
  # }
  
# only needed for var checking  
  tmp <- psych::describe(dt)
  View(tmp)
  write.csv(tmp, file = 'data/cleaned data/psychDescribe.csv')
  
# make representative if needed
  if(sum(grepl("representative", names(dt))) == 1 ){ # if the sum of columns that have the string representative == 2
    dt <- dt[grepl("Rep", dt$representative),]  # reduce df to representative
  } else { # if not
    dt <- dt # keep dt
  }
# Export Dataframe
# Naming
  namSPSS <- paste0("../psyCorona-Analysis/data/raw data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),".sav")
  namR <- paste0("../psyCorona-Analysis/data/raw data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),".Rdata")
  namCSV <- paste0("../psyCorona-Analysis/data/raw data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),".csv")
# Export
  write_sav(dt, namSPSS)
  save(dt, file = namR)
  write.csv(dt, file = namCSV)
rm(dt, namSPSS, namR, namCSV)
```

### RMD21 (Gomez)
```{r RMD21, echo=T, warning=F, message=F}
dataCreate("RMD21", 21)
```

### RMD22 (Erica)
```{r RMD22, echo=T, warning=F, message=F}
dataCreate("RMD22", 22)
```

### RMD23 (Hoon-Seok Choi)
```{r RMD23, echo=T, warning=F, message=F}
dataCreate("RMD23", 23)
```

### RMD24 (Erica)
```{r RMD24, echo=T, warning=F, message=F}
dataCreate("RMD24", 24)
```

### RMD25 (Lemay)
```{r RMD25, echo=T, warning=F, message=F}
dataCreate("RMD25", 25)
```

### RMD26 (Wollast)
```{r RMD26, echo=T, warning=F, message=F}
dataCreate("RMD26", 26)
```

### RMD27 (Douglas)
```{r RMD27, echo=T, warning=F, message=F}
dataCreate("RMD27", 27)
```

### RMD28 (Sutton)
```{r RMD28, echo=T, warning=F, message=F}
dataCreate("RMD28", 28)
```

### RMD29
```{r RMD29, echo=T, warning=F, message=F}
dataCreate("RMD29", 29)
```

### RMD30 (Caspar)
```{r RMD30, echo=T, warning=F, message=F}
dataCreate("RMD30", 20) #yes on the first go there was no structured seed yet
```

### RMD31 (Pica)
```{r RMD31, echo=T, warning=F, message=F}
dataCreate("RMD31", 31)
```

### RMD32 (Elena Resta)
```{r RMD32, echo=T, warning=F, message=F}
dataCreate("RMD32", 32)
```

### RMD33 (Silvana Mula)
```{r RMD33, echo=T, warning=F, message=F}
dataCreate("RMD33", 33)
```

### RMD34 (van Dellen)
```{r RMD34, echo=T, warning=F, message=F}
dataCreate("RMD34", 34)

# make US dataset where data is matched to ZIP
  # prepare dataframe
name <- 'RMD34'
# from here everything is automatic (just need to change the name above)
  author <- namedtReq %>%
    dplyr::select(one_of(paste0(name, '_vars'))) %>% # select the column in which the name and vars are
    as.character() # make it a character
  author <- strsplit(author, "\n")[[1]][3] # get the author which is the third occurence after \n

# make df  
  tmp <- dtReq %>% 
    dplyr::select(name = var, # get variable names
                  request = one_of(paste0(name, '_vars'))) # and the requested columns
 
  tmp <- tmp %>% #remove empty rows
    dplyr::filter(request != "") 
  
# run function to get requested variable names 
  varNames <- apply(tmp, 1, nameOut); rm(tmp)

# make dataframe
  dt <- dtAll %>%
    dplyr::select(one_of(as.character(varNames)),
                 -contains("_DO_"),
                 -contains(".c"),
                 -contains(".m"),
                 -contains(".z"),
                 -contains(".fa"),
                 -countryCitizenIfNo,
                 -whatRel)
  
# needs response ID (make through digest)
  dt$ResponseId <- c(1:nrow(dt))
  for (i in 1:nrow(dt)) {
  dt$ResponseId[i] <- digest::digest(dtAll$ResponseId[i], algo = "xxhash32", seed = 34)
  }
  
# this dataset only wants the Netherlands
  dt <- dt %>%
  filter(coded_country == "United States of America") #this proposal only wants the US
  
# prepare dataframe for merge
  mergedt <- haven::read_spss("data/raw data/ZIP/mergedforjannis.sav")
  mergedt <- mergedt %>%
    mutate(mergeID = as.character(ZIP))
# remove duplicate postal codes (requested by Michelle)
  mergedt <- mergedt %>%
    dplyr::distinct(mergeID, .keep_all = T)

# make merge ID in the created df
  dt$mergeID <- dt$ZIP_1_TEXT %>%
    tolower() %>% #make them lower case
    gsub(" ", "", ., fixed = TRUE) %>% # remove white space
    as.character()
  
# and merge them 
  dt <- dplyr::left_join(dt, mergedt, by = "mergeID")
  
# remove ZIP again
  dt <- dt %>%
    dplyr::select(-contains("ZIP", ignore.case = T),
                  -ends_with("_TEXT", ignore.case = T),
                  -contains("mergeID", ignore.case = T),
                  -ST,
                  -FIPS,
                  -County,
                  -County_Name,
                  -stateFIPS,
                  -statecounty
                  )
  
# make representative if needed
  if(sum(grepl("representative", names(dt))) == 1 ){ # if the sum of columns that have the string representative == 2
    dt <- dt[grepl("Rep", dt$representative),]  # reduce df to representative
  } else { # if not
    dt <- dt # keep dt
  }
    
# Export Dataframe
# Naming
  namSPSS <- paste0("data/collab data/c19 collab Data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),"_USdata.sav")
  namCSV <- paste0("data/collab data/c19 collab Data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),"_USdata.csv")
# Export
  write_sav(dt, namSPSS)
  write.csv(dt, file = namCSV)
rm(dt, namSPSS, namCSV)
```

### RMD35 (Maja Kutlaca)
```{r RMD35, echo=T, warning=F, message=F}
dataCreate("RMD35", 35)
```

### RMD36 (Michelle and William)
```{r RMD36, echo=T, warning=F, message=F}
# make full dataset
  dataCreate("RMD36", 36)

# make US dataset where data is matched to ZIP
  # prepare dataframe
name <- 'RMD36'
# from here everything is automatic (just need to change the name above)
  author <- namedtReq %>%
    dplyr::select(one_of(paste0(name, '_vars'))) %>% # select the column in which the name and vars are
    as.character() # make it a character
  author <- strsplit(author, "\n")[[1]][3] # get the author which is the third occurence after \n

# make df  
  tmp <- dtReq %>% 
    dplyr::select(name = var, # get variable names
                  request = one_of(paste0(name, '_vars'))) # and the requested columns
 
  tmp <- tmp %>% #remove empty rows
    dplyr::filter(request != "") 
  
# run function to get requested variable names 
  varNames <- apply(tmp, 1, nameOut); rm(tmp)

# make dataframe
  dt <- dtAll %>%
    dplyr::select(one_of(as.character(varNames)),
                 -contains("_DO_"),
                 -contains(".c"),
                 -contains(".m"),
                 -contains(".z"),
                 -contains(".fa"),
                 -countryCitizenIfNo,
                 -whatRel)
  
# needs response ID (make through digest)
  dt$ResponseId <- c(1:nrow(dt))
  for (i in 1:nrow(dt)) {
  dt$ResponseId[i] <- digest::digest(dtAll$ResponseId[i], algo = "xxhash32", seed = 36)
  }
  
# this dataset only wants the Netherlands
  dt <- dt %>%
  filter(coded_country == "United States of America") #this proposal only wants the US
  
# prepare dataframe for merge
  mergedt <- haven::read_spss("data/raw data/ZIP/mergedforjannis.sav")
  mergedt <- mergedt %>%
    mutate(mergeID = as.character(ZIP))
# remove duplicate postal codes (requested by Michelle)
  mergedt <- mergedt %>%
    dplyr::distinct(mergeID, .keep_all = T)

# make merge ID in the created df
  dt$mergeID <- dt$ZIP_1_TEXT %>%
    tolower() %>% #make them lower case
    gsub(" ", "", ., fixed = TRUE) %>% # remove white space
    as.character()
  
# and merge them 
  dt <- dplyr::left_join(dt, mergedt, by = "mergeID")
  
# remove ZIP again
  dt <- dt %>%
    dplyr::select(-contains("ZIP", ignore.case = T),
                  -ends_with("_TEXT", ignore.case = T),
                  -contains("mergeID", ignore.case = T),
                  -ST,
                  -FIPS,
                  -County,
                  -County_Name,
                  -stateFIPS,
                  -statecounty
                  )
  
# add representative info if needed
  if(sum(grepl("representative", names(dt))) == 1 ){ # if the sum of columns that have the string representative == 2
    dt$representative <- factor(dtAll$source, 
                                levels = c(1,2,3,4,5,6,7,8), 
                                labels = c("No", "No", "No", "No", "No", "Yes", "Yes", "Yes"))  # add column for representative
  } else { # if not
    print("Representative indication not requested!")
    dt <- dt # keep dt
  }
  
# Merge Requested Meta-Data to requested variables
  # make df  
  tmp <- dtReqMeta %>% 
    dplyr::select(origin = Origin,
                  path = var, # get variable names
                  mergTech = min,
                  request = one_of(paste0(name, '_vars'))) # and the requested columns
  
   tmp <- tmp %>% #remove empty rows
    dplyr::filter(request != "")
  # split the string at "/" and get the fifth; also remove everything after the dot; for loop needed so it does it for each row
  # seperately
   if(nrow(tmp) > 0 ){
     tmp$name <- NA
     for(i in 1:nrow(tmp)) {
       tmp$name[i] <- gsub(".csv", "", strsplit(tmp$path[i], "[/]")[[1]][5])  
     }
     rm(i)
   }
     
   # print the requested datasets and run for loop for the merge
    if(nrow(tmp) == 0 ){ # if row length is 0
      print("No Meta-Data requested")
    } else { # if not
      
      # for loop to merge each dataset according to its merging mechanism (iso or more complicated)
        for (i in 1:nrow(tmp)) {
          if(tmp$mergTech[i] == "countryiso3") {
            print(paste("Merging ", tmp$name[i], ". Please Wait...", sep = "")) #which variable is merging
            dt <- merge_files(dt, tmp$name[i], metadata_location)
          }
          else if(tmp$mergTech[i] == "difficult") {
            print(paste("Merging ", tmp$name[i], ". Not optimally merged but for now this works...", sep = ""))
            dt <- merge_files(dt, tmp$name[i], metadata_location)
          }
          else {
            print(paste("Merging complicated stuff: ", tmp$name[i], ". Computer says no...", sep = ""))
          }
  
        } 
    }
 
# remove irrelevant columns 
  dt <- dt %>%
   dplyr::select(-matches('^country..$'),
                 -matches('^region..$'),
                 -countryiso3)
    
# Export Dataframe
# Naming
  namSPSS <- paste0("data/collab data/c19 collab Data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),"_USdata.sav")
  namCSV <- paste0("data/collab data/c19 collab Data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),"_USdata.csv")
# Export
  write_sav(dt, namSPSS)
  write.csv(dt, file = namCSV)
rm(dt, namSPSS, namCSV)
```

### RMD37 (Lindsy Richardson)
```{r RMD37, echo=T, warning=F, message=F}
dataCreate("RMD37", 37)
```

### RMD38 (Yasin Koc)
```{r RMD38, echo=T, warning=F, message=F}
dataCreate("RMD38", 38)
```

### RMD39 (Birga Schumpe)
```{r RMD39, echo=T, warning=F, message=F}
dataCreate("RMD39", 39)
```

### RMD40 (Leslie Zwerwer)
```{r RMD40, echo=T, warning=F, message=F}
dataCreate("RMD40", 40)
```

### RMD41 (Jose Rama)
```{r RMD41, echo=T, warning=F, message=F}
dataCreate("RMD41", 41)
```

### RMD42 (Michael Stuton)
```{r RMD42, echo=T, warning=F, message=F}
dataCreate("RMD42", 42)
```

### RMD43
```{r RMD43, echo=T, warning=F, message=F}
dataCreate("RMD43", 43)
```

### RMD44 (violeta Enea)
```{r RMD44, echo=T, warning=F, message=F}
dataCreate("RMD44", 44)
```

### RMD45 (Anton Kurapov)
```{r RMD45, echo=T, warning=F, message=F}
dataCreate("RMD45", 45)
```

### RMD46 (Pontus Leander)
```{r RMD46, echo=T, warning=F, message=F}
dataCreate("RMD46", 46)
```

### RMD47 (Antje von Suchodoletz & Shanzey Altaf)
```{r RMD47, echo=T, warning=F, message=F}
dataCreate("RMD47", 47)

# make US dataset where data is matched to ZIP
  # prepare dataframe
name <- 'RMD47'
# from here everything is automatic (just need to change the name above AND THE SEED NUMBER)
  author <- namedtReq %>%
    dplyr::select(one_of(paste0(name, '_vars'))) %>% # select the column in which the name and vars are
    as.character() # make it a character
  author <- strsplit(author, "\n")[[1]][3] # get the author which is the third occurence after \n

# make df  
  tmp <- dtReq %>% 
    dplyr::select(name = var, # get variable names
                  request = one_of(paste0(name, '_vars'))) # and the requested columns
 
  tmp <- tmp %>% #remove empty rows
    dplyr::filter(request != "") 
  
# run function to get requested variable names 
  varNames <- apply(tmp, 1, nameOut); rm(tmp)

# make dataframe
  dt <- dtAll %>%
    dplyr::select(one_of(as.character(varNames)),
                 -contains("_DO_"),
                 -contains(".c"),
                 -contains(".m"),
                 -contains(".z"),
                 -contains(".fa"),
                 -countryCitizenIfNo,
                 -whatRel)
  
# needs response ID (make through digest)
  dt$ResponseId <- c(1:nrow(dt))
  for (i in 1:nrow(dt)) {
  dt$ResponseId[i] <- digest::digest(dtAll$ResponseId[i], algo = "xxhash32", seed = 47)
  }
  
# this dataset only wants the Netherlands
  dt <- dt %>%
  filter(coded_country == "United States of America") #this proposal only wants the US
  
# prepare dataframe for merge
  mergedt <- haven::read_spss("data/collab data/Shared/Data/raw data/ZIP/mergedforjannis.sav")
  mergedt <- mergedt %>%
    mutate(mergeID = as.character(ZIP))
# remove duplicate postal codes (requested by Michelle)
  mergedt <- mergedt %>%
    dplyr::distinct(mergeID, .keep_all = T)

# make merge ID in the created df
  dt$mergeID <- dt$ZIP_1_TEXT %>%
    tolower() %>% #make them lower case
    gsub(" ", "", ., fixed = TRUE) %>% # remove white space
    as.character()
  
# and merge them 
  dt <- dplyr::left_join(dt, mergedt, by = "mergeID")
  
# remove ZIP again
  dt <- dt %>%
    dplyr::select(-contains("ZIP", ignore.case = T),
                  -ends_with("_TEXT", ignore.case = T),
                  -contains("mergeID", ignore.case = T),
                  -ST,
                  -FIPS,
                  -County,
                  -County_Name,
                  -stateFIPS,
                  -statecounty
                  )
  
# make representative if needed
  if(sum(grepl("representative", names(dt))) == 1 ){ # if the sum of columns that have the string representative == 2
    dt <- dt[grepl("Rep", dt$representative),]  # reduce df to representative
  } else { # if not
    dt <- dt # keep dt
  }
    
# Export Dataframe
# Naming
  namSPSS <- paste0("data/collab data/c19 collab Data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),"_USdata.sav")
  namCSV <- paste0("data/collab data/c19 collab Data/", name, "_", author, "_", format(Sys.time(), format = "%F %H-%M %Z"),"_USdata.csv")
# Export
  write_sav(dt, namSPSS)
  write.csv(dt, file = namCSV)
rm(dt, namSPSS, namCSV)
```

### RMD48 (Peter Strelan)
```{r RMD48, echo=T, warning=F, message=F}
dataCreate("RMD48", 48)
```

### RMD49 (Anne-Kathrin)
```{r RMD49, echo=T, warning=F, message=F}
dataCreate("RMD49", 49)
```

### RMD50 (Max and Marie)
```{r RMD50, echo=T, warning=F, message=F}
dataCreate("RMD50", 50)
dataCreate("RMD50", 12) # for Ed so he can merge with Claudia (RMD12) dataset to check for the responseSetMean problems
```

### RMD51 (Edona Berisha-Kida)
```{r RMD49, echo=T, warning=F, message=F}
dataCreate("RMD51", 51)
```

### RMD54 (Marieke van Vlugt)
```{r RMD54, echo=T, warning=F, message=F}
dataCreate("RMD54", 54)
```

### RMD55 (Alexandra Gheorghiu)
```{r RMD55, echo=T, warning=F, message=F}
dataCreate("RMD55", 55)
```

### RMD56 (Alexandra Gheorghiu)
```{r RMD55, echo=T, warning=F, message=F}
dataCreate("RMD56", 56)
```

### RMD57 (Nadta Tenva)
```{r RMD55, echo=T, warning=F, message=F}
dataCreate("RMD57", 57)
```

### RMD58 (Michele Gelfand)
```{r RMD55, echo=T, warning=F, message=F}
dataCreate("RMD58", 58)
```

### RMD60 (Milly Belm)
```{r RMD55, echo=T, warning=F, message=F}
dataCreate("RMD60", 60)
```

### RMD61 (Thesis 2020)
```{r RMD55, echo=T, warning=F, message=F}
dataCreate("RMD61", 61)
```

### RMD62 (Fischer)
```{r RMD55, echo=T, warning=F, message=F}
dataCreate("RMD62", 62)
```

### RMD63 (Counted)
```{r RMD55, echo=T, warning=F, message=F}
dataCreate("RMD63", 63)
```

### RMD64 (Cowden)
```{r RMD55, echo=T, warning=F, message=F}
dataCreate("RMD64", 64)
```

### RMD65 (Lucas)
```{r RMD55, echo=T, warning=F, message=F}
dataCreate("RMD65", 65)
```

### RMD66 (Claudia)
```{r RMD66, echo=T, warning=F, message=F}
dataCreate("RMD66", 66)
```

### RMD67 (Frank)
```{r RMD66, echo=T, warning=F, message=F}
dataCreate("RMD67", 67)
```

### RMD68 (Kei)
```{r RMD68, echo=T, warning=F, message=F}
dataCreate("RMD68", 68)
```

### RMD69 (Robin Wollast)
```{r RMD69, echo=T, warning=F, message=F}
dataCreate("RMD69", 69)
```

### RMD70-91 (Milly)
```{r RMD66, echo=T, warning=F, message=F}
dataCreate("RMD70", 70)
dataCreate("RMD71", 70)
dataCreate("RMD72", 70)
dataCreate("RMD73", 70)
dataCreate("RMD74", 70)
dataCreate("RMD75", 70)
dataCreate("RMD76", 70)
dataCreate("RMD77", 70)
dataCreate("RMD78", 70)
dataCreate("RMD79", 70)
dataCreate("RMD80", 70)
dataCreate("RMD81", 70)
dataCreate("RMD82", 70)
dataCreate("RMD83", 70)
dataCreate("RMD84", 70)
dataCreate("RMD85", 70)
dataCreate("RMD86", 70)
dataCreate("RMD87", 70)
dataCreate("RMD88", 70)
dataCreate("RMD89", 70)
dataCreate("RMD90", 70)
dataCreate("RMD91", 70)
```

### RMD92 (Bang)
```{r RMD66, echo=T, warning=F, message=F}
dataCreate("RMD92", 92)
```

### RMD93 (Stroebe)
```{r RMD66, echo=T, warning=F, message=F}
dataCreate("RMD93", 93)
```
